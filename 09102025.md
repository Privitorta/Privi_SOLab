# SO(LAB) 9 Ottobre 2025

Il file `.iso` non mantiene storage (come disco, non scrivibile); simula la disponibilità di un disco fisso ma a ogni accesso non si trova quello svolto la volta precedente (non c'è **persistenza**). Ma è atteso come comportamento.

## La Lezione delle Forche
```bash
wget http://homes.di.unimi.it/re/SYSOPLAB_24_25/L3.tar.gz
tar -xvzf L3.tar.gz
```

Famigerata lezione delle **FORCHE**!!!
Reminder segmenti in cui, generalmente, è suddivisa la **Memoria Virtuale**:
- Text (*codice*, read-only)
- Dati inizializzati
- Stack
- Heap

## Shell

Interprete dei comandi che l'utente da al sistema operativo, ne esistono grafiche e testuali. (Linux: `bash` più diffusa). Offre costrutti di base di un linguaggio di programmazione. Funziona, generalmente, così:
- Attesa input utente
- Interpretazione del comando utente
- Esecuzione comando/i utente

Implementare una shell richiede l'uso della chiamata di sistema `fork` (duplica un processo).

### Parentela tra processi
Il processo creante è detto **parent**, creato è **child**. Ogni processo (tranne `init`) ha un parent quindi si forma un "albero" di parentela.

### Creazione di processi
Richiede alcune operazioni da parte del SO:
- Creazione nuovo ID (PID - Process Identifier)
- Allocare memoria (codice, dati)
- Allocare altre risorse (stdin, stdout, dispositivi I/O...)
- Gestione informazoni sul nuovo processo (es. priorità)
- Creazione PCB (Process Control Block) che contiene informazioni precedenti

> `init` ha PID=1, è il primo processo (creato durante boot)

Cosa succede dopo che un processo viene creato?

### Relazioni dinamiche
Il processo **parent** può:
- Attendere la terminazione del processo **child**
```bash
top
```
Il terminale è associato al nuovo processo.
- Continuare senza attendere (es. esecuzione in *background*)
```bash
sleep 500 &
```

Quando un comando viene eseguito in background al genitore, notifica il suo PID.

```bash
ps
```

## Relazione di contenuto
Due possibilità:
- Processo **child** è un duplicato del **parent** (Unix)
- Il figlio esegue un programma differente (Windows)
> Citati sono i comportamenti standard, ma entrambi sono eseguibili da ambedue i sistemi

## SYSCALL fork
Permette di creare un duplicato di un processo **parent**. Appartiene allo standard POSIX (Portable Operating System Interface) di IEEE (Insitute of Electrical and Electronics Engineering). Essa crea un nuovo processo che:
- Condivide la medesima area codice del processo **parent**
- Usa una copia dell'area dati del processo **parent**
- Ha un PID differente dal **parent** (utile per compiere diverse operazioni su un processo e sull'altro)

### Valori di ritorno di fork

- <0 Errore
- =0 Processo **child**
- \>0 Processo **parent** (il valore di ritorno è il PID del **child**)

`pid_t` è un signed integer MA!!! potrebbe anche essere di dimensioni differenti, quindi bisogna usare `pid_t`.

#### Processo orfano
Il processo **parent** termina la propria esecuzione prima del processo **child**. Può capitare quando, ad esempio, inseriamo una *sleep* subito prima della printf nel file `fork3.c`.

```bash
cp fork1.c fork3.c
gcc fork3.c -o fork3
./fork3
```

#### Processo zombie
Sono processi terminati, ma in attesa che il processo **parent** rilevi il loro stato di terminazione. Per osservare la generazione di un processo **zombie** basta porre la *sleep* prima della printf del processo **parent**.

![](/plantsvszombies.jpg)

## SYSCALL exec
Permette di eseguire un programma diverso da quello che ha effettuato la fork, **exec** sostituisce codice e dati di un processo con quelli di un programma differente.

Ha diverse varianti che si differenziano in base a:
- formato degli argomenti (lista o array argv[])
- utilizzo o meno del path della shell

La exec ritorna solamente in caso di errore (-1). In caso di successo, il vecchio codice è completamente sostituito dal nuovo e non è più possibile tornare al programma originale.

## Thread POSIX
Un thread è un'unità di esecuzione all'interno di un processo, un processo può avere più thread in esecuzione che tipicamente condividono le **risorse** del processo e, in particolare, la **memoria**. Lo standard POSIX definisce un insieme di funzioni per la creazione e la sincronizzazione di thread.

```C
pthread_create (pthread_t *thead, pthread_attr_t *attr, void *(*start_routine) void *), void *arg)
```

- **thread**: un puntatore a `pthread_t`, l'analogo di `pid_t`. non è necessariamente implementato come intero
- **attr**: attributi del nuovo thread; se non si vogliono modificare gli attributi è sufficiente passare `NULL`
- **start_routine**: codice da eseguire, è un puntatore a funzione che prende un puntatore a void e restituisce un puntatore a void
- **arg**: eventuali argomenti da passare (`NULL` se non si intende passare parametri)

Per terminare l'esecuzione di un thread, si usa la funzione `pthread_exit` che termina l'esecuzione di un thread restituendo un valore di ritorno.

```C
pthread_exit(void *retval)
```

Per attendere la terminazione di un generico thread th si usa la funzione `pthread_join`; se ha successo ritorna 0 e un puntatore

> niente ho perso il filo

