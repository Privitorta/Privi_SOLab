# SO(LAB) 25 Settembre 2025
6h (Lanzi) + 4h (Re) di lezione settimanali (12 CFU) tra teoria e laboratorio.

**Esame:** Scritto, domande aperte a risposta multipla + orale & prova pratica di laboratorio <br>
**Libro**: "Operating Systems: Three Easy Pieces" (Remzi H. Arpaci-Dusseau, Andrea C. Arpaci-Dusseau)

[http://homes.di.unimi.it/sisop/](http://homes.di.unimi.it/sisop/)<br>
[https://homes.di.unimi.it/re/solabL2.html](https://homes.di.unimi.it/re/solabL2.html)

## Introduzione
Il sistema operativo è un insieme di programmi che gestisce in modo ottimale le risorse finite della macchina e, fondamentalmente, facilita a utenti/programmatori l'utilizzo della sottostante macchina hardware.

![](/assets/25092025/modellocipollaSO.png)

Questo è il modello a cipolla di un sistema di calcolo, delle sue componenti.

### Kernel mode / User mode
Il sistema operativo è l'unico programma che ha totale controllo delle risorse hardware della macchina; questo privilegio prende il nome di **kernel mode**. Gli altri programmi presenti si appoggiano ai servizi del SO e la loro esecuzione viene controllata e gestita da quest'ultimo, dunque ci troviamo in **user mode**. In molti processori, questa distinzione di modalità d'utilizzo del SO è impostata tramite hardware.

### Esecuzione di un programma
**Algoritmo**: descrizione priva di ambiguità di un'attività di elaborazione dell'informazione. Necessita la specifica di un interprete che, dato un set di *istruzioni* e un set di *dati input*, esegua l'algoritmo.

**Interprete**: può essere un concetto astratto o un dispositivo fisico reale; è in grado di riconoscere i set di istruzioni che gli vengono dati in pasto, dunque è opportuno osservare convenzioni sintattiche durante la scrittura dell'algoritmo se vogliamo che la sua esecuzione funzioni correttamente dall'interprete.

![](/assets/25092025/esecuzioneprogramma.png)

## Macchina di Von Neumann

Per capire come un algoritmo generico possa essere eseguito da un calcolatore consideriamo il modello semplificato del processore **IA-32**, la macchina di Von Neumann:

![](/assets/25092025/vonneumann.png)

I concetti fondamentali:
- La memoria viene usata per conservare sia il programma che i dati sui quali questo opera
- L'hardware opera secondo il ciclo `fetch`, `decode`, `execute`:
  - `fetch`: recupera dalla memoria la prossima istruzione da eseguire
  - `decode`: decodifica il significato dei bit (codice istruzione)
  - `execute`: esecuzione istruzione ricavata dalla codifica

### Macchina i386
`i` indica "Intel" (produttore), `386` sta per terza generazione della famiglia x86, risale al 1985. È stato il primo processore ad implementare la microarchitettura **IA-32**, quindi la prima effettiva CPU a 32 bit.

**CISC - Complex Instruction Set Computer**: molte istruzioni differenti, ognuna con diverse modalità di uso (es. numero diverso di parametri).

La i386 presenta diversi registri e ha una *Real* mode e una *Protected* mode.

#### Real/Protected Mode
|                          | Real mode | 32bit Protected Mode |
| ------------------------ | --------- | -------------------- |
| Protezioni HW            | no        | si                   |
| Spazio di indirizzamento | $2^{20}$  | $2^{35}$             |

**Real mode**: memoria max $2^{20}$ bytes, indirizzo ottenuto con due registri a 16 (`SS:OFFSET`)
*indirizzo = 16 * selettore + offset*
- ci sono più modi per riferirsi allo stesso indirizzo, ad esempio, `07C0:0000` e `0000:7C00` sono la stessa locazione fisica
- A20 gate

**Protected mode**: il segmento è stabilito da un descrittore (che può essere cambiato solo in kernel mode).

![](/assets/25092025/i386programmerview.png)

- **EIP** (Instruction Pointer)
  - indirizzo di prossima istruzione
- **Registers** (Registri generali)
  - dati di uso frequente (accesso rapido)
- **Flag di stato** (Condition Codes, CC)
  - informazioni riguardo alle più recenti operazioni aritmetiche logiche
- **Memoria**
  - Array ordinato di byte
  - Codice, dati (user), dati SO
  - Stack (supporto procedure)

## Assembly
Esistono diverse famiglie sintattiche di Assembly (Intel, AT&T):
- [NASM](http://nasm.sourceforge.org)
- [PC Assembly Language](http://drpaulcarter.com/pcasm/) (*Paul A. Carter*)
- [Gas](http://www.ibm.com/developerworks/linux/library/l-gas-nasm/index.html)
```assembly
move eax, 3      ; eax = 3
mov bx, ax       ; bx = ax
add eax, 4       ; eax = eax + 4
add al, ah       ; al = al + ah
L8:db "A"        ; *L8 = 'A'
mov al, [L8]     ; al = *L8
```
**OPCODE**: singola istruzione che può essere eseguita dalla CPU; in linguaggio macchina, è un valore rappresentabile come un numero binario o esadecimale (es. *B6*), in Assembly è una parola chiave più facile da memorizzare per il programmatore (es. `mov`, `add`, `sub`, `jmp`...)
```
mov eax, 4       ; COMMAND DST, SRC
```
Il comando è sempre presente, il numero di operandi varia da 0 a 3 (nei casi più comuni).

| Intel(NASM)         | AT&T(as86, Gas)      |
| ------------------- | -------------------- |
| `mov` ebx, eax      | `movl` %eax, %ebx    |
| `mov` eax, 42       | `movl` $42, %eax     |
| `mov` [ebx], eax    | `movl` %eax, 0(%ebx) |
| `mov` [ebx+4], eax  | `movl` %eax, 4(%ebx) |
| `mov` byte[ebx], al | `movb` %eax, 0(%ebx) |
| `call` eax          | `call` *%eax         |

### Caratteristiche
Tipi di dati **minimali**:
- Integer
- Floating-point
- <u>NON ESISTONO</u> tipi aggregati (array, struct)
  - Solo byte allocati in modo contiguo in memoria

Operazioni **primitive**:
- Operazioni aritmetiche su registri e dati in memoria
- Trasferimento dati tra memoria e registri
  - Copia da memoria a registro, da registro a memoria, da registro a registro, ma <u>NON</u> da memoria a memoria
- Controllo di flusso
  - Salti incondizionati da e verso procedure
  - Salti incondizionati

### IA-32 Instruction Sets
**Convenzioni operandi** versione ridotta (alcuni esempi):
![](/assets/25092025/ia-32instructionset1.png)
Trasferimento dati 1, **DST $\leftarrow$ SRC**:
![](/assets/25092025/ia-32instructionset2.png)
Trasferimento dati 2:
![](/assets/25092025/ia-32instructionset3.png)
Manipolazione STACK:
![](/assets/25092025/ia-32instructionset4.png)
Aritmetica binaria:
![](/assets/25092025/ia-32instructionset6.png)
Istruzioni logiche:
![](/assets/25092025/ia-32instructionset7.png)
Trasferimento controllo 1:
![](/assets/25092025/ia-32instructionset8.png)
Trasferimento controllo 2:
![](/assets/25092025/ia-32instructionset9.png)
I/O Porte:
![](/assets/25092025/ia-32instructionset5.png)

## Porta
Ogni periferica è dotata di un controller. Il controller avrà dei registri che conservano lo stato della periferica; per accedere (leggere/scrivere) al contenuto di questi si usano:
- Spazi di indirizzamento separati chiamati **PORT**, a cui si accede con istruzioni particolari:
  - `out` port, eax
  - `in` eax, port
- **Memory mapped I/O**, lo spazio di indirizzamento è unico
  - `mov` [address], eax
  - `mov` eax, [address]

## Dal codice alto livello al codice basso livello
Per passare dal linguaggio di alto livello al codice macchina, gli strumenti necessari sono:
- Compilatore
- Assembler
  - Traduce in `.s` o `.o`
  - Traduce ogni istruzione nella sua controparte in codifica binaria
  - Risultato estremamente vicino al codice eseguito dalla macchina
  - Mancano i collegamenti tra il codice sorgente contenuto in file diversi
- Linker
  - Risolve i riferimenti tra il codice contenuto in diversi sorgenti
  - Combina il risultato ottenuto con codice di librerie standard
    - es. codice `malloc`, `printf`
  - Alcune librerie sono linkate in modo dinamico
    - Il link è effettuato al momento dell'inizio dell'esecuzione del programma

![](/assets/25092025/altolivellobassolivello.png)

### Addizione di due interi con segno

**C**
```C
int t = x + y;
```
Regolare addizione di due interi con segno.

**Assembly**
```assembly
addl 8(%ebp), %eax
```
Addizione di due interi (da 4 byte):
- "Long" words
- Stesse istruzioni per interi con e senza segno

Operandi:
- `y`: registro %eax
- `x`: memoria M [%ebp+8]
- `t`: registro %eax
  - ritorna valore in %eax

**Codice oggetto**
```
ox401046: 03 45 08
```
Istruzione in 3 byte, salvata all'indirizzo `0x401046`

### C > Assembly > Codice oggetto
**C**
```C
int sum(int x, int y) {
  int t = x + y;
  return t;
}
```

**Assembly** (Gas AT&T)
```
_sum:
      pushl %ebp
      movl %esp, %ebp
      movl 12(%ebp), %eax
      addl 8(%ebp), %eax
      movl %ebp, %esp
      popl %ebp
      ret
```
**Codice oggetto**
```assembly
0x401040 <sum>:
    0x55
    0x89
    0xe5
    0x8b
    0x45
    0x0c
    0x03
    0x45
    0x08
    0x89
    0xec
    0x5d
    0xc3
```
13 bytes, ogni istruzione 1, 2 o 3 bytes. L'indirizzo iniziale è `0x401040`.

Come si disassembla un codice oggetto?

```assembly
00401040 <_sum>:
0: 55                   push %ebp
1: 89 e5                mov %esp, %ebp
3: 8b 45 0c             mov 0xc(%ebp), %eax
6. 03 45 08             add 0x8(%ebp), %eax
9: 89 ec                mov %ebp, %esp
b: 5d                   pop %ebp
c: c3                   ret
d: 8d 76 00             lea 0x0(%esi), %esi
```

Uno strumento utile all'analisi del codice oggetto è `objdump -d p`:
- Analisi pattern di bit corrispondenti a serie istruzioni
- Corrispondenza approssimata con codice assembly
- Applicabile a `a.out` (eseguibile completo) o il file `.o`

Altrimenti, mediante debugger GDB: `gdb p (o file.o)`
- `disassemble sum` disassembla la funzione
- `x/13b sum` esamina 13 byte dall'inizio di `sum`
- 
```
% objdump -d WINWORD.EXE

WINWORD.EXE:     file format pei-i386

No symbols in "WINWORD.EXE".
Disassembly of section .text:

30001000 <.text>:
30001000: 55              push   %ebp
30001001: 8b ec           mov    %esp,%ebp
30001003: 6a ff           push   $0xffffffff
30001005: 68 90 10 00 30  push   $0x30001090
3000100a: 68 91 dc 4c 30  push   $0x304cdc91
```
Tutto ciò che può essere interpetato come codice eseguibile. Il disassemblatore interpreta in byte e ricostruisce il sorgente assembly.

### Muovere dati
**Muovere (copiare) dati**:
```
movl src, dst
```
Questa istruzione muove 4 byte ("long") word e viene usata frequentemente.

**Tipi di operando**
- **Immediato**: costante intera
  - Come costante C, ma ha prefisso '$'
  - es. `$0x400`, `$-533`
  - 1, 2, o 4 byte
- **Registri**: `eax`, `edx`, `ecx`, `ebx`, `esi`, `edi`, `esp`, `ebp`...
  - `%esp` e `%ebp` riservati per usi speciali
- **Memoria**: 4 byte consecutivi
  - Varie modalità di indirizzamento

**`movl`: Combinazioni operandi ammesse**

![](/assets/25092025/combinazionioperandimovl.png)
**NON** ammette trasferimento da <u>memoria a memoria</u> in una singola istruzione.

### Modalità di indirizzamento
Esistono diverse modalità di indirizzamento.

**(R) Mem[Reg[R]]**
- Il registro R contiene un indirizzo di memoria
- `movl (%ecx), %eax`
- 
**Displacement D(R) Mem[Reg[R]+D]**
- Il registro R punta ad una posizione in memoria
- Costante D specifica offset
- `movl 8(%ebp), %edx`

## Esempio funzione: SWAP

Allegati file usati `swap.c` e `swap.asm` come traduzione in linguaggio assembly.

```C
#include <stdio.h>
#include <stdlib.h>

void swap(int *xp, int *yp) {
    int t0 = *xp;
    int t1 = *yp;
    *xp = t1;
    *yp = t0;
}
```

```assembly
swap:
; setup
  pushl %ebp
  movl %esp,%ebp
  pushl %ebx
; body
  movl 12(%ebp),%ecx
  movl 8(%ebp),%edx
  movl (%ecx),%eax
  movl (%edx),%ebx
  movl %eax,(%edx)
  movl %ebx,(%ecx)
; finish
  movl -4(%ebp),%ebx
  movl %ebp,%esp
  popl %ebp
  ret
```

## Sequenza di boot
Cosa succede quando si accende un PC?
- Inizia l'esecuzione del programma contenuto nel firmware (BIOS)
- Il BIOS carica il programma contenuto nel **boot sector**
- Il programma di boot carica il SO
- Il controllo della macchina è affidato al SO, a cui dovranno essere richiesti i caricamenti di altri programmi

![](/assets/25092025/bootsequence.png)

### Analisi via Qemu/GDB (Linux)
Analizziamo la sequenza di boot i386 tramite ambiente virtuale:
```bash
qemu-system-i386 -S -gdb tcp::42000
```
- `qemu-system-i386`: Eseguibile dell'emulatore; il nome può cambiare
- `-S`: STOP, lancia Qemu e lo blocca in attesa di comandi
- `-gdb tcp::42000`: Si aggancia al debugger GDB rimanendo in attesa di istruzioni da esso sulla porta 42000

```bash
matteo@matteo-UX32VDA:~$ gdb
GNU gdb (Ubuntu/Linaro 7.4-2012.04-0ubuntu2.1) 7.4-2012.04
Copyright (C) 2012 Free Software Foundation, Inc.

License GPLv3+: GNU GPL version 3 or later 
<http://gnu.org/licenses/gpl.html>

This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show 
copying" and "show warranty" for details.

This GDB was configured as "x86_64-linux-gnu".

For bug reporting instructions, please see:
<http://bugs.launchpad.net/gdb-linaro/>

(gdb) target remote localhost:42000
Remote debugging using localhost:42000
0x0000fff0 in ?? ()

(gdb) 
```
- `matteo@matteo-UX32VDA:~$ gdb`: Serve a eseguire GDB
- `(gdb) target remote localhost:42000`: Connettiamo GDB all'emulatore Qemu, con conferma connessione avvenuta
- `(gdb)`: Prompt GDB

Per esaminare il contenuto in memoria:
```bash
(gdb) x/x 0x0
0x0: 0x00000000

(gdb) x/2x 0x0
0x0: 0x00000000 0x00000000

(gdb) x/i 0x0
0x0: add    %al,(%eax)
```
- `(gdb) x/x 0x0`: x/nfu addr; `n`, `f`, `u` sono parametri opzionali
  - `n`: repeat count, quanta memoria mostrare (in unità u)
  - `f`: display format. s (stringa terminata da NULL), i (istruzione codice macchina), x (esadecimale)
  - `u`: unit size, uno dei seguenti valori:
    - b = bytes
    - h = half word (2 bytes)
    - w = word (4 bytes)
    - g = giant word (8 bytes)
- `0x0: add    %al,(%eax)`: Il comando examine (x) mostra che anche 0x00000000 è un'istruzione valida in codice macchina

Quale comando sta per essere eseguito dalla macchina?
```assembly
(gdb) info registers
eax            0x0 0
ecx            0x0 0
edx            0x633 1587
ebx            0x0 0
esp            0x0 0x0
ebp            0x0 0x0
esi            0x0 0
edi            0x0 0
eip            0xfff00xfff0     ; o
eflags         0x2 [ ]
cs             0xf000 61440     ; b
ss             0x0 0
ds             0x0 0
es             0x0 0
fs             0x0 0
gs             0x0 0
(gdb)
```
Per motivi di compatibilità il processore, al momento dell'accensione, è in modalità 
**Reale** (simile a quella con cui funzionavano i processori Intel 8086).

Gli indirizzi a 20 bit in modalità reale sono ottenuti sempre mediante somma di un 
indirizzo di base `b` ed uno spiazzamento `o`: `i = b · 16 + o`
- `b`: Base register in `cs`
- `o`: Offset in `eip`
- In esadecimale, moltiplicare per 16 equivale ad aggiungere uno 0
```
i = 0xf000 · 16 + 0xfff0
i = 0xf0000 + 0xfff0
i = 0xffff0
(si può scrivere anche 0xf0000:0xfff0)
```
Il costruttore ha scelto quest'indirizzo come indirizzo della prima istruzione che verrà eseguita; questa scelta è cablata nell'hardware una volta e vale per tutte.

La prima istruzione che verrà eseguita dalla macchina, quindi, è all'indirizzo `0xffff0`. Per verificare che ci sia qualcosa al suo interno:
```bash
(gdb) set architecture i8086
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration of GDB. Attempting to continue with the default i8086 settings. The target architecture is assumed to be i8086

(gdb) x/i 0xffff0
   0xffff0: ljmp   $0xf000,$0xe05b
```
Salta ad un'altra posizione più bassa in memoria, ma perchè?

$2^{20} = 1.024.576$<br>$(fff0)_{h} = (1.048.560)_{10}$

```bash
(gdb) x/i 0xffff0
   0xffff0: ljmp   $0xf000,$0xe05b
```
In effetti c'è qualcosa; un programma precaricato dal costruttore che è in grado di caricare un altro programma dalla memoria di massa. È un sistema operativo minimale BIOS (Basic Input/Output System), serve a caricare un sistema operativo più completo (e scelto dall'utente).

Ricordando gli step che avvengono al boot del PC, parliamo del secondo, quello in cui il BIOS carica il programma contenuto nel **boot sector**.

### Boot sector
![](/assets/25092025/bootsector.png)

Prendiamo ad esempio un programma che calcola l'MCD con l'algoritmo di Euclide; calcoliamolo di `420` e `240` useremo poi la notazione NASM (Intel). Prima definiamo l'algoritmo in alto livello:

```python
def mcd(x,y):
    assert(x>0 and y>0)
    if x==y: return x 
    elif x > y: return mcd(x-y, y)
    else: return mcd(x,y-x)
```

In Assembly, `MCD(420,240)` diventa:
```assembly
main:   mov dx, 420     ; dx = 420
        mov bx, 240     ; bx = 240
max:    cmp dx, bx      ;ZF = (dx==bx);CF = (dx < bx)
        je fine         ; if(ZF) goto fine
        jg diff         ; if!(ZF || CF) goto diff
        mov ax, dx      ; ax = dx
        mov dx, bx      ; dx = bx
        mov bx, ax      ; bx = ax
diff:   sub dx, bx      ; dx -= bx
        jmp max         ; goto max
fine:   hlt             ; halt/*dx == mcd(420,240)*/
```

Perchè il programma possa essere caricato dal BIOS serve seguire delle **regole**; qualora lo si carichi da un disco magnetico, il programma:
- Dev'essere conservato nel primo settore del disco
- Il primo settore deve contenere massimo *512 byte*
- Il primo settore deve terminare (byte 511 e 512) con i byte AA55

> L'intera sequenza verrà caricata a partire dall'indirizzo `0x0000:0x7c00`. Per completare, dobbiamo apportare alcune modifiche al file Assembly precedente

```assembly
segment .text
global main

main:   mov dx, 420     ; dx = 420
        mov bx, 240     ; bx = 240
max:    cmp dx, bx      ;ZF = (dx==bx);CF = (dx < bx)
        je fine         ; if(ZF) goto fine
        jg diff         ; if!(ZF || CF) goto diff
        mov ax, dx      ; ax = dx
        mov dx, bx      ; dx = bx
        mov bx, ax      ; bx = ax
diff:   sub dx, bx      ; dx -= bx
        jmp max         ; goto max
fine:   hlt             ; halt/*dx == mcd(420,240)*/

times 510-($-$$)db 0
dw 0xAA55
```

Ora, per assemblare:
```bash
nasm -f bin -o mcdboot.bin mcd1.asm
```
Il programma va assemblato in un formato contenente puro codice macchina (-f bin). Ed eseguiamo Qemu obbligandolo a usare `mcdboot.bin` per emulare il primo hard disk (opzione `-hda`):
```bash
qemu-system-i386 -S -hda mcdboot.bin -gdb tcp::42000
```
Connettiamo il debugger e indaghiamo:
```bash
(gdb) target remote localhost:42000
Remote debugging using localhost:42000
0x0000fff0 in ?? ()

(gdb) x/x 0x7c00
0x7c00: 0x00000000          # La memoria risulta vuota qui a 0x7c00

(gdb) b* 0x7c00             # Impostiamo breakpoint
Breakpoint 1 at 0x7c00

(gdb) c                     # Continuiamo esecuzione
Continuing.
Breakpoint 1, 0x00007c00 in ?? ()

(gdb) set architecture i8086
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration of GDB. Attempting to continue with the default i8086 settings. The target architecture is assumed to be i8086

(gdb)
```
Da qui, vediamo che la memoria all'indirizzo `0x7c00` è vuota, quindi settiamo con `b*` un breakpoint a `0x7c00` e poi con `c` continuiamo l'esecuzione.
```bash
(gdb) x/11i 0x7c00
=> 0x7c00: mov    $0x1a4,%dx
   0x7c03: mov    $0xf0,%bx
   0x7c06: cmp    %bx,%dx
   0x7c08: je     0x7c16
   0x7c0a: jg     0x7c12
   0x7c0c: mov    %dx,%ax
   0x7c0e: mov    %bx,%dx
   0x7c10: mov    %ax,%bx
   0x7c12: sub    %bx,%dx
   0x7c14: jmp    0x7c06
   0x7c16: hlt
   
(gdb) si
0x00007c03 in ?? ()

(gdb) p $dx
$1 = 420

(gdb)
```
Ora all'indirizzo `0x7c00` è presente il nostro programma di calcolo MCD. con `si` eseguiamo una singola istruzione, la prima (`mov $0x1a4, %dx`) quindi ora in `dx` troviamo `420`.

#### La scheda video

Il problema è che l'unico modo di conoscere il risultato è esaminare il contenuto nel registro dx quando l'esecuzione raggiunge l'ultima esecuzione, e ciò è **poco comodo**; sarebbe meglio rendere il dato disponibile mediante l'uso di una periferica adatta, ad esempio, lo *schermo*. Per avere una cosa del genere, serve usare la scheda video che controlla lo schermo scrivendo i dati da visualizzare nella memoria di questa.

Se ci interessa usarla per via testuale, generalmente può essere pilotata secondo le convenzioni introdotte con l'IBM *Monochrome Display Adapter* (MDA) montata sul PC originale nel 1981. Lo schermo viene usato come una griglia rettangolare di caratteri. MDA aveva 4Kb di memoria accessibile tramite indirizzi della memoria fisica del PC; questa tecnica si chiamava **Memory Mapped I/O** e permette di accedere alle risorse hardware tramite operazioni di manipolazione di memoria del sistema (*Indirizzi di memoria → mapping → parole di memoria gestite dalla periferica*).

General x86 Real Mode Memory Map:
```
0x00000000 - 0x000003FF - Real Mode Interrupt Vector Table
0x00000400 - 0x000004FF - BIOS Data Area
0x00000500 - 0x00007BFF - Unused
0x00007C00 - 0x00007DFF - Bootloader
0x00007E00 - 0x0009FFFF - Unused
  0x000A0000 - 0x000BFFFF - Video RAM (VRAM) Memory – graphic modes
  0x000B0000 - 0x000B7777 - Monochrome Video Memory – txt mode
  0x000B8000 - 0x000BFFFF - Color Video Memory – txt mode (color)
0x000C0000 - 0x000C7FFF - Video ROM BIOS
0x000C8000 - 0x000EFFFF - BIOS Shadow Area
0x000F0000 - 0x000FFFFF - System BIOS
```
Nel caso di MDA, la convenzione è quella di considerare gli indirizzi a partire da `0xb8000` come corrispondenti a un array di $80 \cdot 25 = 2000$ coppie di bytes.

```
0x000A0000 - 0x000BFFFF - Video RAM (VRAM) Memory
0x000B0000 - 0x000B7777 - Monochrome Video Memory
0x000B8000 - 0x000BFFFF - Color Video Memory
```
Scrivere in `0x000B8000` stampa un carattere sullo schermo, ad esempio:
```assembly
%define VIDMEM 0xB8000    ; video memory

mov edi, VIDMEM            ; get pointer to video memory
mov [edi], 'A'             ; print character 'A'
mov [edi+1], 0x7           ; character attribute
```

### DMA e Memory Mapped I/O
Ma se io volessi scrivere un carattere in una posizione scelta da me nella griglia 25x80? Una proprietà utile che stiamo manipolando in questo esempio, della memoria, è che è **lineare**; se raggiungiamo la fine di una riga di testo, il prossimo carattere verrà stampato sulla riga seguente, sfruttando la linearità della memoria la formula per scrivere ad una data posizione x(riga)/y(colonna) sullo schermo è `x + y * colonne_schermo`.
> Per scrivere 1 carattere servono 2 bytes; il primo specifica il carattere (standard ASCII) e il secondo il suo formato sullo schermo

```assembly
segment .text
global main

QUANTI equ 100          ; #define QUANTI 100
N equ QUANTI*2-2        ; #define N (QUANTI*2-2)
main:   mov ax, 0xb800  ; /* mov ds, x è vietato */
        mov ds, ax      ; ds = ax
        mov cx, QUANTI  ; /* cx è indice per loop */
        mov bx, N       ; bx = N
ciclo:                  ; do {   
        mov byte[ds:bx], 'm' ; mem[ds:bx]='m'
        sub bx, 2       ; bx -= 2
        loop ciclo      ; } while(cx!=0)
fine:   hlt             ; halt/*dx == mcd(420,240)*/

times 510-($-$$)db 0
dw 0xAA55
```
Si compila come spiegato precedentemente:
```bash
nasm -f bin mdamioboot.bin mdamio.asm ; qemu-system-i386 -hda mdamioboot.bin -gdb tcp::42000
```
Poi ci si connette al GDB e si va avanti come prima, il programma così stamperà dei caratteri sullo schermo sfruttando il Memory Mapped I/O.
> L'indice del ciclo `cx` è automaticamente decrementato grazie all'istruzione `loop`

L'indirizzo effettivo a cui si fa riferimento nella prima `mov` del ciclo è calcolato secondo le regole della Real mode: `0xb800` $\cdot 16 +(100-2)_{10}=$ `0xb8062`. Dopo si procede a ritroso saltando il byte dei parametri di visualizzazione.

### Supporto BIOS per la gestione del video
Il software di base precaricato potrebbe talvolta offrire una libreria di funzioni utili per semplificare la scrittura dei programmi che interagiscono con le periferiche; nei PC IBM compatibili, la zona di memoria da `0XA0000` a `0x100000` è in sola lettura (ROM) e in essa sono presenti una serie di *routine* per la gestione dell'hardware; il **firmware**, software fornito dal produttore e cablato nella memoria della macchina, come il BIOS.
Come si accede a queste routine?
- Potremmo usare una chiamata a procedura (`call`), ma il problema è che in varie versioni le medesime routine potrebbero trovarsi a indirizzi diversi
- Meccanismo di **chiamata implicita**. Sfrutta il meccanismo hardware di protezione; è uno dei fondamentali di dialogo tra applicazioni e sistema operativo

#### Chiamata implicita
Sfrutta il meccanismo delle interruzioni hardware; in questo caso è lanciata via software quindi si parla di *software interrupt* invece di *interrupt request (IRQ)* come nel caso di richieste di interruzioni derivanti da periferiche.

L'effetto è che il processore salva parte del proprio stato e salta all'indirizzo dell'apposito <u>gestore di interruzione</u> che si può impostare programmando opportunamente **PIC** e **memoria**. Al termine dell'esecuzione della procedura che gestisce l'interruzione e il processore ripristina il proprio stato al momento antecedente l'arrivo dell'interruzione e procede.

Il produttore del firmware deve garantire l'inizializzazione di una tabella di gestori delle interruzioni contenente i dati necessari a raggiungere una routine e pubblicare l'associazione tra una <u>data interruzione</u> e una <u>data periferica</u>.

Nei BIOS dei PC IBM compatibili, l'interruzione 16 (0x10) viene utilizzata per controllare la scheda video e stampare. Il protocollo da seguire è questo:
1. Mettere nel byte basso di AX (AL) il carattere da stampare
2. Mettere nel byte alto di AX (AH) un valore che indica la modalità di visualizzazione (es. 0X0e → modalità testuale standard)
3. Utilizzare il registro BX per impostare gli attributi estetici (luminosità, colore ecc.)
4. Lanciare l'interruzione 0x10 (BIOS, scrivi su schermo e sposta cursore)

```assembly
segment .text
global main

main:
; set it only once.
MOV    AH, 0Eh    ; select sub-function.
MOV    AL, 'H'    ; ASCII code: 72
INT    10h        ; print it!
MOV    AL, 'e'    ; ASCII code: 101
INT    10h        ; print it!
MOV    AL, 'l'    ; ASCII code: 108
INT    10h        ; print it!
MOV    AL, 'l'    ; ASCII code: 108
INT    10h        ; print it!
MOV    AL, 'o'    ; ASCII code: 111
INT    10h        ; print it!
MOV    AL, '!'    ; ASCII code: 33
INT    10h        ; print it!
fine:   hlt       ; halt

times 510-($-$$)db 0
dw 0xAA55
```
Poi:
```bash
nasm -f bin biosintimpboot.bin biosintimp.asm ; qemu-system-i386 -hda biosintimpboot.bin -gdb tcp::42000
```
Il programma stamperà caratteri a schermo, sfruttando le routine del firmware.