# SO(LAB) 25 Settembre 2025
6h (Lanzi) + 4h (Re) di lezione settimanali (12 CFU) tra teoria e laboratorio.

**Esame:** Scritto, domande aperte a risposta multipla + orale & prova pratica di laboratorio <br>
**Libro**: "Operating Systems: Three Easy Pieces" (Remzi H. Arpaci-Dusseau, Andrea C. Arpaci-Dusseau)

[http://homes.di.unimi.it/sisop/](http://homes.di.unimi.it/sisop/)<br>
[https://homes.di.unimi.it/re/solabL2.html](https://homes.di.unimi.it/re/solabL2.html)

## Introduzione
Il sistema operativo è un insieme di programmi che gestisce in modo ottimale le risorse finite della macchina e, fondamentalmente, facilita a utenti/programmatori l'utilizzo della sottostante macchina hardware.

![](/assets/25092025/modellocipollaSO.png)

Questo è il modello a cipolla di un sistema di calcolo, delle sue componenti.

### Kernel mode / User mode
Il sistema operativo è l'unico programma che ha totale controllo delle risorse hardware della macchina; questo privilegio prende il nome di **kernel mode**. Gli altri programmi presenti si appoggiano ai servizi del SO e la loro esecuzione viene controllata e gestita da quest'ultimo, dunque ci troviamo in **user mode**. In molti processori, questa distinzione di modalità d'utilizzo del SO è impostata tramite hardware.

### Esecuzione di un programma
**Algoritmo**: descrizione priva di ambiguità di un'attività di elaborazione dell'informazione. Necessita la specifica di un interprete che, dato un set di *istruzioni* e un set di *dati input*, esegua l'algoritmo.

**Interprete**: può essere un concetto astratto o un dispositivo fisico reale; è in grado di riconoscere i set di istruzioni che gli vengono dati in pasto, dunque è opportuno osservare convenzioni sintattiche durante la scrittura dell'algoritmo se vogliamo che la sua esecuzione funzioni correttamente dall'interprete.

![](/assets/25092025/esecuzioneprogramma.png)

## Macchina di Von Neumann

Per capire come un algoritmo generico possa essere eseguito da un calcolatore consideriamo il modello semplificato del processore **IA-32**, la macchina di Von Neumann:

![](/assets/25092025/vonneumann.png)

I concetti fondamentali:
- La memoria viene usata per conservare sia il programma che i dati sui quali questo opera
- L'hardware opera secondo il ciclo `fetch`, `decode`, `execute`:
  - `fetch`: recupera dalla memoria la prossima istruzione da eseguire
  - `decode`: decodifica il significato dei bit (codice istruzione)
  - `execute`: esecuzione istruzione ricavata dalla codifica

### Macchina i386
`i` indica "Intel" (produttore), `386` sta per terza generazione della famiglia x86, risale al 1985. È stato il primo processore ad implementare la microarchitettura **IA-32**, quindi la prima effettiva CPU a 32 bit.

**CISC - Complex Instruction Set Computer**: molte istruzioni differenti, ognuna con diverse modalità di uso (es. numero diverso di parametri).

La i386 presenta diversi registri e ha una *Real* mode e una *Protected* mode.

#### Real/Protected Mode
|                          | Real mode | 32bit Protected Mode |
| ------------------------ | --------- | -------------------- |
| Protezioni HW            | no        | si                   |
| Spazio di indirizzamento | $2^{20}$  | $2^{35}$             |

**Real mode**: memoria max $2^{20}$ bytes, indirizzo ottenuto con due registri a 16 (`SS:OFFSET`)
*indirizzo = 16 * selettore + offset*
- ci sono più modi per riferirsi allo stesso indirizzo, ad esempio, `07C0:0000` e `0000:7C00` sono la stessa locazione fisica
- A20 gate

**Protected mode**: il segmento è stabilito da un descrittore (che può essere cambiato solo in kernel mode).

![](/assets/25092025/i386programmerview.png)

- **EIP** (Instruction Pointer)
  - indirizzo di prossima istruzione
- **Registers** (Registri generali)
  - dati di uso frequente (accesso rapido)
- **Flag di stato** (Condition Codes, CC)
  - informazioni riguardo alle più recenti operazioni aritmetiche logiche
- **Memoria**
  - Array ordinato di byte
  - Codice, dati (user), dati SO
  - Stack (supporto procedure)

## Assembly
Esistono diverse famiglie sintattiche di Assembly (Intel, AT&T):
- [NASM](http://nasm.sourceforge.org)
- [PC Assembly Language](http://drpaulcarter.com/pcasm/) (*Paul A. Carter*)
- [Gas](http://www.ibm.com/developerworks/linux/library/l-gas-nasm/index.html)
```asm
move eax, 3      ; eax = 3
mov bx, ax       ; bx = ax
add eax, 4       ; eax = eax + 4
add al, ah       ; al = al + ah
L8:db "A"        ; *L8 = 'A'
mov al, [L8]     ; al = *L8
```
**OPCODE**: singola istruzione che può essere eseguita dalla CPU; in linguaggio macchina, è un valore rappresentabile come un numero binario o esadecimale (es. *B6*), in Assembly è una parola chiave più facile da memorizzare per il programmatore (es. `mov`, `add`, `sub`, `jmp`...)
```
mov eax, 4       ; COMMAND DST, SRC
```
Il comando è sempre presente, il numero di operandi varia da 0 a 3 (nei casi più comuni).

| Intel(NASM)         | AT&T(as86, Gas)      |
| ------------------- | -------------------- |
| `mov` ebx, eax      | `movl` %eax, %ebx    |
| `mov` eax, 42       | `movl` $42, %eax     |
| `mov` [ebx], eax    | `movl` %eax, 0(%ebx) |
| `mov` [ebx+4], eax  | `movl` %eax, 4(%ebx) |
| `mov` byte[ebx], al | `movb` %eax, 0(%ebx) |
| `call` eax          | `call` *%eax         |

### Caratteristiche
Tipi di dati **minimali**:
- Integer
- Floating-point
- <u>NON ESISTONO</u> tipi aggregati (array, struct)
  - Solo byte allocati in modo contiguo in memoria

Operazioni **primitive**:
- Operazioni aritmetiche su registri e dati in memoria
- Trasferimento dati tra memoria e registri
  - Copia da memoria a registro, da registro a memoria, da registro a registro, ma <u>NON</u> da memoria a memoria
- Controllo di flusso
  - Salti incondizionati da e verso procedure
  - Salti incondizionati

### IA-32 Instruction Sets
**Convenzioni operandi** versione ridotta (alcuni esempi):
![](/assets/25092025/ia-32instructionset1.png)
Trasferimento dati 1, **DST $\leftarrow$ SRC**:
![](/assets/25092025/ia-32instructionset2.png)
Trasferimento dati 2:
![](/assets/25092025/ia-32instructionset3.png)
Manipolazione STACK:
![](/assets/25092025/ia-32instructionset4.png)
Aritmetica binaria:
![](/assets/25092025/ia-32instructionset6.png)
Istruzioni logiche:
![](/assets/25092025/ia-32instructionset7.png)
Trasferimento controllo 1:
![](/assets/25092025/ia-32instructionset8.png)
Trasferimento controllo 2:
![](/assets/25092025/ia-32instructionset9.png)
I/O Porte:
![](/assets/25092025/ia-32instructionset5.png)

## Porta
Ogni periferica è dotata di un controller. Il controller avrà dei registri che conservano lo stato della periferica; per accedere (leggere/scrivere) al contenuto di questi si usano:
- Spazi di indirizzamento separati chiamati **PORT**, a cui si accede con istruzioni particolari:
  - `out` port, eax
  - `in` eax, port
- **Memory mapped I/O**, lo spazio di indirizzamento è unico
  - `mov` [address], eax
  - `mov` eax, [address]

## Dal codice alto livello al codice basso livello
Per passare dal linguaggio di alto livello al codice macchina, gli strumenti necessari sono:
- Compilatore
- Assembler
  - Traduce in `.s` o `.o`
  - Traduce ogni istruzione nella sua controparte in codifica binaria
  - Risultato estremamente vicino al codice eseguito dalla macchina
  - Mancano i collegamenti tra il codice sorgente contenuto in file diversi
- Linker
  - Risolve i riferimenti tra il codice contenuto in diversi sorgenti
  - Combina il risultato ottenuto con codice di librerie standard
    - es. codice `malloc`, `printf`
  - Alcune librerie sono linkate in modo dinamico
    - Il link è effettuato al momento dell'inizio dell'esecuzione del programma

![](/assets/25092025/altolivellobassolivello.png)

### Addizione di due interi con segno

**C**
```C
int t = x + y;
```
Regolare addizione di due interi con segno.

**Assembly**
```
addl 8(%ebp), %eax
```
Addizione di due interi (da 4 byte):
- "Long" words
- Stesse istruzioni per interi con e senza segno

Operandi:
- `y`: registro %eax
- `x`: memoria M [%ebp+8]
- `t`: registro %eax
  - ritorna valore in %eax

**Codice oggetto**
```
ox401046: 03 45 08
```
Istruzione in 3 byte, salvata all'indirizzo `0x401046`

### C > Assembly > Codice oggetto
**C**
```C
int sum(int x, int y) {
  int t = x + y;
  return t;
}
```

**Assembly** (Gas AT&T)
```
_sum:
      pushl %ebp
      movl %esp, %ebp
      movl 12(%ebp), %eax
      addl 8(%ebp), %eax
      movl %ebp, %esp
      popl %ebp
      ret
```
**Codice oggetto**
```
0x401040 <sum>:
    0x55
    0x89
    0xe5
    0x8b
    0x45
    0x0c
    0x03
    0x45
    0x08
    0x89
    0xec
    0x5d
    0xc3
```
13 bytes, ogni istruzione 1, 2 o 3 bytes. L'indirizzo iniziale è `0x401040`.

Come si disassembla un codice oggetto?

```
00401040 <_sum>:
0: 55                   push %ebp
1: 89 e5                mov %esp, %ebp
3: 8b 45 0c             mov 0xc(%ebp), %eax
6. 03 45 08             add 0x8(%ebp), %eax
9: 89 ec                mov %ebp, %esp
b: 5d                   pop %ebp
c: c3                   ret
d: 8d 76 00             lea 0x0(%esi), %esi
```

Uno strumento utile all'analisi del codice oggetto è `objdump -d p`:
- Analisi pattern di bit corrispondenti a serie istruzioni
- Corrispondenza approssimata con codice assembly
- Applicabile a `a.out` (eseguibile completo) o il file `.o`

Altrimenti, mediante debugger GDB: `gdb p (o file.o)`
- `disassemble sum` disassembla la funzione
- `x/13b sum` esamina 13 byte dall'inizio di `sum`
- 
```
% objdump -d WINWORD.EXE

WINWORD.EXE:     file format pei-i386

No symbols in "WINWORD.EXE".
Disassembly of section .text:

30001000 <.text>:
30001000: 55              push   %ebp
30001001: 8b ec           mov    %esp,%ebp
30001003: 6a ff           push   $0xffffffff
30001005: 68 90 10 00 30  push   $0x30001090
3000100a: 68 91 dc 4c 30  push   $0x304cdc91
```
Tutto ciò che può essere interpetato come codice eseguibile. Il disassemblatore interpreta in byte e ricostruisce il sorgente assembly.

### Muovere dati
**Muovere (copiare) dati**:
```
movl src, dst
```
Questa istruzione muove 4 byte ("long") word e viene usata frequentemente.

**Tipi di operando**
- **Immediato**: costante intera
  - Come costante C, ma ha prefisso '$'
  - es. `$0x400`, `$-533`
  - 1, 2, o 4 byte
- **Registri**: `eax`, `edx`, `ecx`, `ebx`, `esi`, `edi`, `esp`, `ebp`...
  - `%esp` e `%ebp` riservati per usi speciali
- **Memoria**: 4 byte consecutivi
  - Varie modalità di indirizzamento

**`movl`: Combinazioni operandi ammesse**

![](/assets/25092025/combinazionioperandimovl.png)
**NON** ammette trasferimento da <u>memoria a memoria</u> in una singola istruzione.

### Modalità di indirizzamento
Esistono diverse modalità di indirizzamento.

**(R) Mem[Reg[R]]**
- Il registro R contiene un indirizzo di memoria
- `movl (%ecx), %eax`
- 
**Displacement D(R) Mem[Reg[R]+D]**
- Il registro R punta ad una posizione in memoria
- Costante D specifica offset
- `movl 8(%ebp), %edx`

